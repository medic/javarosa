package org.javarosa.j2me.storage.rms;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import javax.microedition.rms.InvalidRecordIDException;
import javax.microedition.rms.RecordEnumeration;
import javax.microedition.rms.RecordStore;
import javax.microedition.rms.RecordStoreException;
import javax.microedition.rms.RecordStoreFullException;
import javax.microedition.rms.RecordStoreNotFoundException;
import javax.microedition.rms.RecordStoreNotOpenException;

import org.javarosa.core.log.LogEntry;
import org.javarosa.core.log.WrappedException;
import org.javarosa.core.model.utils.DateUtils;
import org.javarosa.core.services.Logger;
import org.javarosa.core.services.storage.EntityFilter;
import org.javarosa.core.services.storage.IStorageIterator;
import org.javarosa.core.services.storage.IStorageUtility;
import org.javarosa.core.services.storage.Persistable;
import org.javarosa.core.services.storage.StorageFullException;
import org.javarosa.core.util.externalizable.CannotCreateObjectException;
import org.javarosa.core.util.externalizable.DeserializationException;
import org.javarosa.core.util.externalizable.ExtUtil;
import org.javarosa.core.util.externalizable.ExtWrapMap;
import org.javarosa.core.util.externalizable.Externalizable;
import org.javarosa.core.util.externalizable.ExternalizableWrapper;
import org.javarosa.core.util.externalizable.PrototypeFactory;
import org.javarosa.j2me.log.StatusReportException;
import org.javarosa.j2me.log.XmlStatusProvider;
import org.kxml2.kdom.Element;

/**
 * class StorageUtility
 * 
 * This class provides a persistent record store, built on top of RMS. StorageUtility takes a name which uniquely
 * identifies it, and associates it with several underlying RMSes. Each StorageUtility is meant to store records
 * (objects) of a single type. Different StorageUtilitys can be instantiated (with different names) to handle
 * records/objects of different types.
 * 
 * Features of StorageUtility:
 *   * available storage is not limited by the size constraints of a single RMS; records will spill over into
 *     additional RMSes as needed
 *   * records can have their own ID numbers independent of the ID numbers generated by RMS
 *   * access is completely thread-safe
 *   * recover gracefully from RMS errors, particularly RMS full. tries hard to not leave the storage structure in
 *     an inconsistent state, and if it is, you'll at least know about it
 * 
 * StorageUtility can be used in two flavors: you manage the IDs, or the utility manages the IDs:
 * 
 * If you manage the IDs, the objects you are storing must implement Persistable, which provides the ID from the object
 * itself. You then use the functions read(), write(), and remove() when dealing with storage.
 * 
 * If the utility manages the IDs, your objects need only implement Externalizable. You use the functions read(), add(),
 * update(), and remove(). add() will return a new ID for the record, which you then explicitly provide to all subsequent
 * calls to update().
 * 
 * These two schemes should not be mixed within the same StorageUtility.
 * 
 */
public class RMSStorageUtility implements IStorageUtility, XmlStatusProvider {
	private static final int MAX_RMS_NAME_LENGTH = 32;		//maximum length of an RMS name
	private static final int SUFFIX_LENGTH = 3;				//how much of RMS name that we need to reserve for our own purposes
	private static final int MAX_DATA_STORES = 100;			//max number of data RMSes
	
	/* hard-coded ID numbers of specific records in the indexing RMS */
	private static final int TX_FLAG_REC_ID = 1;			//status flag
	private static final int STORAGE_INFO_REC_ID = 2;		//general info (# records, # data stores, etc.)
	private static final int ID_INDEX_REC_ID = 3;			//record ID -> record location index
	private static final int RESERVE_BUFFER_REC_ID = 4;		//safety buffer
	
	/* amount of safety buffer we want to keep for unexpected size increases to our indexing structures. this is important as
	 * we don't support rolling back updates to the data records. if we successfully change the data, but don't have enough
	 * space to update the indexes, the StorageUtility will become corrupt! (which can be repaired, but may result in data loss
	 * for the record most recently touched
	 */
	private static final int RESERVE_BUFFER_SIZE = 400;
	
	/* statuses that the StorageUtility may have */
	private static final int STATUS_UNINITIALIZED = -1;		/* StorageUtility still being initialized and not ready for action
															   will only be seen in the wild if the constructor failed */
	private static final int STATUS_CLEAN = 0;				/* StorageUtility is in a consistent state and ready for action */
	private static final int STATUS_DIRTY = 1;				/* StorageUtility is in an inconsistent state, meaning some sort of
															   transaction is in progress, or the previous transaction failed
															   in a way we could not recover from (meaning the StorageUtility
															   must be repaired before it can be used again) */
	
	/* static collection of storage-related objects -- one per unique StorageUtility name -- mainly useful for thread management */
	private static Hashtable storageStaticInfo = new Hashtable();
	
	private String basename;		//unique name identifying this collection of records
	private Class type;				//type of object this StorageUtility stores
	private boolean allocateIDs;    //if true, will auto-assign IDs to Persistables with an ID of -1
	
	private RMS indexstore;			//RMS wrapper for the indexing RMS
	private RMS[] datastores;		//RMS wrappers for 1..n data RMSes (are loaded as needed, so entries may be null)
	
	public RMSStorageUtility (String basename, Class type) {
		this(basename, type, true);
	}
	
	/**
	 * Instantiate a new StorageUtility. Will create the underlying skeleton RMSes if they don't exist
	 * 
	 * @param basename unique name identifying this StorageUtility. Different collections of the same type of object
	 *   can be kept distinct by giving their StorageUtilitys different names (e.g., "PATIENTS" and "DEMO_PATIENTS")
	 * @param type object type that this StorageUtility stores and retrieves. this class must implement Externalizable
	 */
	public RMSStorageUtility (String basename, Class type, boolean allocateIDs) {
		validateName(basename);
		validateDataType(type);
		
		this.basename = basename;
		this.type = type;
		this.allocateIDs = allocateIDs;
		
		initStaticInfo();
			
		loadIndexStore();
	}
	
	public String getName () {
		return basename;
	}
	
	public Class getType () {
		return type;
	}
	
	/**
	 * Read and return the record corresponding to 'id'.
	 * 
	 * @param id id of the object
	 * @return object for 'id'. null if no object is stored under that ID
	 */
	public Externalizable read (int id) {
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			if (idIndex.containsKey(new Integer(id))) {
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				return (Externalizable)getDataStore(loc.rmsID).readRecord(loc.recID, type);
			} else {
				return null;
			}
			
		}
	}

	/**
	 * Read and return the raw bytes for the record corresponding to 'id'.
	 * 
	 * @param id id of the object
	 * @return raw bytes for the record. null if no record is stored under that ID
	 */
	public byte[] readBytes (int id) {
		synchronized (getAccessLock()) {
			
			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			if (idIndex.containsKey(new Integer(id))) {
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				return getDataStore(loc.rmsID).readRecord(loc.recID);
			} else {
				return null;
			}
			
		}		
	}
	
	/**
	 * Write an object to the store. Will either add a new record, or update the existing record (if one exists) for the
	 * object's ID. This function should never be used in conjunction with add() and update() within the same StorageUtility
	 * 
	 * @param p object to store
	 * @throws StorageFullException if there is not enough room to store the object
	 */
	public void write (Persistable p) throws StorageFullException {
		typeCheck(p);

		RMSRecordLoc newLoc = null;

		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();			
			
			int id = p.getID();
			if (allocateIDs) {			
				if (id == -1) {
					id = info.nextRecordID;
					p.setID(id);
					info.nextRecordID++;
				} else if (id >= info.nextRecordID) {
					info.nextRecordID = id + 1;
				}
			}
						
			byte[] data = ExtUtil.serialize(p);
			
			Hashtable idIndex = getIDIndexRecord();
			boolean recordExists = idIndex.containsKey(new Integer(id));

			setDirty();
						
			//reserve space for updating index/metadata
			int bytesNeededEstimate = (recordExists ? 20 : 40);
			if (!setReserveBuffer(bytesNeededEstimate)) {
				setClean();
				//can't reserve needed space to update index
				throw new StorageFullException();
			}
			
			if (recordExists) {
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				txRecord(id, "update");
				newLoc = updateRecord(loc, data, info);
			} else {
				txRecord(id, "add");
				newLoc = addRecord(data, info);
				if (newLoc != null) {
					info.numRecords++;
				}
			}
			
			//release the space we reserved
			setReserveBuffer(0);
			
			if (newLoc == null) {
				setClean();
				throw new StorageFullException();
			}
			
			idIndex.put(new Integer(id), newLoc);	
			commitIndex(info, idIndex);
			setClean();
			storageModified();			
		}
	}
	
	/**
	 * Add a new record to the store. This function always adds a new record; it never updates an existing record. The
	 * record ID under which this record is added is allocated by the StorageUtility. If this StorageUtility stores
	 * Persistables, you should almost certainly use write() instead.
	 * 
	 * @param e object to add
	 * @return record ID for newly added object
	 * @throws StorageFullException if not enough space available
	 */
	public int add (Externalizable e) throws StorageFullException {
		typeCheck(e);
		
		byte[] data = ExtUtil.serialize(e);

		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();
			int id = info.nextRecordID;
			info.nextRecordID++;
			
			setDirty();
			
			//reserve space for updating index/metadata
			int bytesNeededEstimate = 40;
			if (!setReserveBuffer(bytesNeededEstimate)) {
				setClean();
				//can't reserve needed space to update index
				throw new StorageFullException();
			}
			
			txRecord(id, "add");
			RMSRecordLoc loc = addRecord(data, info);
			
			//release the space we reserved
			setReserveBuffer(0);
						
			if (loc == null) {
				setClean();
				throw new StorageFullException();
			}
			
			Hashtable idIndex = getIDIndexRecord();
			idIndex.put(new Integer(id), loc);
			info.numRecords++;
			
			commitIndex(info, idIndex);
			setClean();
			storageModified();
			
			return id;
		}	
	}
	
	/**
	 * Update a record in the store. The record must have previously been added to the store using add(). If this
	 * StorageUtility stores Persistables, you should almost certainly use write() instead.
	 * 
	 * @param id ID of record to update
	 * @param e updated object
	 * @throws StorageFullException if not enough space available to update
	 * @throws IllegalArgumentException if no record exists for ID
	 */
	public void update (int id, Externalizable e) throws StorageFullException {
		typeCheck(e);
		
		byte[] data = ExtUtil.serialize(e);
		
		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();
			Hashtable idIndex = getIDIndexRecord();
			if (!idIndex.containsKey(new Integer(id))) {
				throw new IllegalArgumentException("Record ID [" + id + "] not found");
			}
	
			setDirty();
			
			//reserve space for updating index/metadata
			int bytesNeededEstimate = 20;
			if (!setReserveBuffer(bytesNeededEstimate)) {
				setClean();
				//can't reserve needed space to update index
				throw new StorageFullException();
			}
			
			RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
			txRecord(id, "update");
			loc = updateRecord(loc, data, info);
	
			//release the space we reserved
			setReserveBuffer(0);
			
			if (loc == null) {
				setClean();
				throw new StorageFullException();
			}
			
			idIndex.put(new Integer(id), loc);
			commitIndex(info, idIndex);
			setClean();
			storageModified();
		}
	}
	
	/**
	 * Remove record with the given ID from the store.
	 * 
	 * @param id ID of record to remove
	 * @throws IllegalArgumentException if no record with that ID exists
	 */
	public void remove (int id) {
		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();
			Hashtable idIndex = getIDIndexRecord();
			if (!idIndex.containsKey(new Integer(id))) {
				throw new IllegalArgumentException("Record ID [" + id + "] not found");
			}
	
			setDirty();
						
			RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
			txRecord(id, "delete");
			getDataStore(loc.rmsID).removeRecord(loc.recID);
			
			info.numRecords--;
			idIndex.remove(new Integer(id));
			commitIndex(info, idIndex);
			setClean();
			storageModified();
		}
	}
	
	/**
	 * Remove object from the store
	 * 
	 * @param p object to remove
	 * @throws IllegalArgumentException if object is not in the store
	 */
	public void remove (Persistable p) {
		typeCheck(p);
		
		remove(p.getID());
	}

	public void removeAll () {
		removeAll(null);
	}
	
	public Vector<Integer> removeAll (EntityFilter filter) {
		synchronized (getAccessLock()) {
			Vector IDs = new Vector();
			
			IStorageIterator ii = iterate();
			while (ii.hasMore()) {
				int id = ii.nextID();
				boolean toRemove;
				
				if (filter == null) {
					toRemove = true;
				} else {
					switch (filter.preFilter(id, null)) {
					case EntityFilter.PREFILTER_INCLUDE: toRemove = true; break;
					case EntityFilter.PREFILTER_EXCLUDE: toRemove = false; break;
					case EntityFilter.PREFILTER_FILTER: toRemove = filter.matches(read(id)); break;
					default: throw new RuntimeException();
					}
				}

				if (toRemove) {
					IDs.addElement(new Integer(id));
				}
			}
						
			for (int i = 0; i < IDs.size(); i++) {
				int id = ((Integer)IDs.elementAt(i)).intValue();
				remove(id);
			}
			
			return IDs;
		}
	}
	
	/**
	 * Return the number of records in the store
	 * 
	 * @return number of records
	 */
	public int getNumRecords () {
		synchronized (getAccessLock()) {

			checkNotCorrupt();			

			return getInfoRecord().numRecords;

		}
	}

	/**
	 * Return whether the store is empty
	 * 
	 * @return true if there are no records in the store
	 */
	public boolean isEmpty () {
		return getNumRecords() == 0;
	}
	
	/**
	 * Return whether a record exists in the store
	 *
	 * @param id record ID
	 * @return true if a record exists for that ID in the store
	 */
	public boolean exists (int id) {
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			return idIndex.containsKey(new Integer(id));
			
		}
	}
	
	/**
	 * Return total size used by this StorageUtility, including all underlying RMSes
	 *
	 * @return total size (bytes)
	 */
	public int getTotalSize () {
		int size = 0;
		
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			RMSStorageInfo info = getInfoRecord();
			
			try {
				size += getIndexStore().rms.getSize();
				for (int i = 0; i < info.numDataStores; i++) {
					size += getDataStore(i).rms.getSize();
				}
			} catch (RecordStoreNotOpenException e) {
				throw new RuntimeException("can't happen");
			}
		}
		
		return size;
	}
	
	/**
	 * Get the size of a record
	 * 
	 * @param id record ID
	 * @return size of that record, in bytes
	 * @throws IllegalArgumentException if no record exists for that ID
	 */
	public int getRecordSize (int id) {
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			if (idIndex.containsKey(new Integer(id))) {			
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				try {
					return getDataStore(loc.rmsID).rms.getRecordSize(loc.recID);
				} catch (RecordStoreException e) {
					throw new RuntimeException("error getting record size");
				}
			} else {
				throw new IllegalArgumentException("Record ID [" + id + "] not found");	
			}
			
		}
	}
	
	/**
	 * Delete the storage utility itself, along with all stored records and meta-data
	 */
	public void destroy () {
		synchronized (getAccessLock()) {
			if (RMSTransaction.anyTxOpen()) {
				throw new RuntimeException("operation not allowed while transactions are active");
			}
			
			throw new RuntimeException("not implemented yet");
		}
	}

	/**
	 * Perform any clean-up/consolidation of the StorageUtility's underlying datastructures that is too expensive to do during
	 * normal usage (e.g., if all the records are scattered among 10 half-empty RMSes, repack them into 5 full RMSes)
	 */
	public void repack () {
		synchronized (getAccessLock()) {
			if (RMSTransaction.anyTxOpen()) {
				throw new RuntimeException("operation not allowed while transactions are active");
			}
			
			throw new RuntimeException("not implemented yet");
		}
	}
	
	/**
	 * If the StorageUtility has been left in a corrupt/inconsistent state, restore it to a non-corrupt state, even if it results
	 * in data loss
	 */
	public void repair () {
		synchronized (getAccessLock()) {
			if (RMSTransaction.anyTxOpen()) {
				throw new RuntimeException("operation not allowed while transactions are active");
			}			
		
			try {
				checkNotCorrupt();
				
				//integrity is ok
				return;
				
			} catch (IllegalStateException ise) {
				//utility is corrupt; fix it
				log("rms-repair", "buf[" + getReserveBufferSize() + "]");
			
				RMSStorageInfo info = getInfoRecord();
				Hashtable idIndex = getIDIndexRecord();

				//check index for entries where record does not exist in rms
				Vector invalidIDs = new Vector();
				int max_datastore = -1;
				for (Enumeration e = idIndex.keys(); e.hasMoreElements(); ) {
					int id = ((Integer)e.nextElement()).intValue();
					RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
					if (loc.rmsID > max_datastore) {
						max_datastore = loc.rmsID;
					}
					
					boolean recordExists = false;
					if (loc.rmsID >= info.numDataStores) {
						log("rms-corrupt", id + " => (" + loc.rmsID + "," + loc.recID + ") data store out of range [" + info.numDataStores + "]");
					} else {
						RMS rms = getDataStore(loc.rmsID);
						if (rms != null && rms.readRecord(loc.recID) != null) {
							recordExists = true;
						} else {
							log("rms-corrupt", id + " => (" + loc.rmsID + "," + loc.recID + ") no record exists");						
						}
					}
					
					if (!recordExists) {
						invalidIDs.addElement(new Integer(id));
					}
				}
				for (int i = 0; i < invalidIDs.size(); i++) {
					idIndex.remove((Integer)invalidIDs.elementAt(i));
				}
				
				//check for rms records that have no corresponding index entry
				//note: this is hte most likely failure scenario
				//TODO -- it's not going to hurt anything for now
				
				//check for uncommitted spillover
				try {
					RMS spilled = new RMS(dataStoreName(info.numDataStores), false);
					if (spilled != null && spilled.rms.getNumRecords() > 0) {
						log("rms-corrupt", "uncommitted spillover rms found");												
					}
				} catch (RecordStoreException rse) {
					//ok
				}
				
				info.numRecords = idIndex.size();
				info.numDataStores = max_datastore + 1;
				info.nextRecordID = info.numRecords + 1;
				
				commitIndex(info, idIndex);
				setReserveBuffer(0);
				setClean();
				storageModified();	
				
				//check again
				try {
					checkNotCorrupt();
					log("rms-repair", "storage utility repaired successfully");
				} catch (IllegalStateException ise2) {
					log("rms-repair", "unable to repair storage utility!!!");
					throw new IllegalStateException("Storage utility [" + basename + "] is corrupt and could not be repaired");
				}
			}

		}
	}
	
	/**
	 * Attempt to commit all changes to the indexing and meta-data structures after a record operation (add/update/remove) has been
	 * done. Throw a fatal exception if any of these commits fail. It is the responsibility of the caller to ensure that there is
	 * enough space to write these updates (such as by reserving a 'safety buffer' of bytes then releasing it immediately prior to
	 * this call). We have no provision for rolling back record changes (add/update/remove), so if these commits fail, the
	 * StorageUtility will be left in a corrupt state, necessitating repair (which in turn may result in data loss). So it is 
	 * important to reserve the necessary space.
	 * 
	 * @param info general StorageUtility info record
	 * @param idIndex ID -> record location mapping
	 */
	private void commitIndex (RMSStorageInfo info, Hashtable idIndex) {
		boolean failed = false;

		if (!failed)
			failed = !writeIDIndexRecord(idIndex);
		if (!failed)
			failed = !writeInfoRecord(info);

		if (failed) {
			System.err.println("We weren't able to commit the updated index and meta-data, even though we thought we had enough space! The utility is now corrupt!!");
			log("rms-corrupt", "unable to commit index; utility is now corrupt");
			throw new RuntimeException("ERROR! Enable to complete action! Utility must be repaired!");
		}
	}
	
	/**
	 * Close all resources associated with this StorageUtility. Any attempt to use this StorageUtility after this call will result
	 * in error. Though not strictly necessary, it is a good idea to call this when you are done with the StorageUtility, as closing
	 * may trigger clean-up in the underlying RMSes (device-dependent behavior) which may reclaim unused space.
	 * 
	 * Don't worry about other StorageUtilitys that reference the same data (such as in other threads); they will reopen their
	 * RecordStores as needed.
	 */
	public void close () {
		synchronized (getAccessLock()) {
			indexstore.close();
			indexstore = null;

			for (int i = 0; i < datastores.length; i++) {
				if (datastores[i] != null) {
					datastores[i].close();
				}
			}
			datastores = null;
		}
	}
	
	/**
	 * Return an iterator to iterate through all records in this StorageUtility
	 * 
	 * @returns record iterator
	 */
	public IStorageIterator iterate () {
		synchronized (getAccessLock()) {
			
			checkNotCorrupt();
			
			Vector IDs = new Vector();
			for (Enumeration e = getIDIndexRecord().keys(); e.hasMoreElements(); ) {
				IDs.addElement(e.nextElement());
			}

			return newIterator(IDs);
			
		}
	}
	
	/**
	 * Trigger for when something modifies the data in the storage utility
	 */
	private void storageModified () {
		invalidateIterators();
	}
	
	/**
	 * Load the indexing/meta-data RMS when this StorageUtility is first instantiated, and check its integrity. Create
	 * it if it doesn't exist. 
	 */
	private void loadIndexStore () {
		synchronized (getAccessLock()) {
			
			RMS ix = null;
			try {
				ix = new RMS(indexStoreName(), false);
			} catch (RecordStoreNotFoundException rsnfe) {
				//do nothing; will create record store next
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error + (" + rse.getClass().getName() + ") opening index record for store " + basename + " : " + rse.getMessage());
			}
			
			if (ix != null) {
				this.indexstore = ix;
			} else {
				initIndexStore();
			}
			
			checkInitialized();			

			this.datastores = new RMS[0];
			getInfoRecord();
			
		}
	}
	
	/**
	 * Create a new indexing/meta-data RMS. The RMS must not exist already.
	 */
	private void initIndexStore () {
		RMS ix = null;
		try {
			ix = new RMS(indexStoreName(), true);
		} catch (RecordStoreException rse) {
			throw new RuntimeException("Error creating index record: " + rse.getMessage());
		}
		
		int recID;
		
		//initialize status flag
		recID = ix.addRecord(ExtUtil.serialize(new Integer(STATUS_UNINITIALIZED)));
		if (recID != TX_FLAG_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		//create default storage info
		recID = ix.addRecord(ExtUtil.serialize(new RMSStorageInfo()));
		if (recID != STORAGE_INFO_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		//create empty record ID index
		recID = ix.addRecord(ExtUtil.serialize(new ExtWrapMap(new Hashtable())));
		if (recID != ID_INDEX_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		//create buffer of reserve bytes
		recID = ix.addRecord(new byte[1]); //RMS has trouble with zero-length records
		if (recID != RESERVE_BUFFER_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		this.indexstore = ix;
		
		setClean();
	}
	
	/**
	 * Add a new record to the data stores. Attempts to add the record to each data store, starting with the lowest,
	 * until it finds a data store that is not full and successfully accepts the record. If all data stores are full,
	 * attempt to spillover by creating and adding to an additional data store.
	 * 
	 * If a spillover data store is created, but does not have enough space for the record, the new (empty) data store is removed
	 * 
	 * @param data serialized byte data for record
	 * @param info StorageUtility info record
	 * @return location record was added to (RMS #, record ID); null if storage is full
	 */
	private RMSRecordLoc addRecord (byte[] data, RMSStorageInfo info) {
		RMSRecordLoc newID = null;
		int iDatastore;
		
		for (iDatastore = info.numDataStores - 1; iDatastore >= 0; iDatastore--) {
			RMS rs = getDataStore(iDatastore);
			int recID = rs.addRecord(data);

			if (recID != -1) {
				newID = new RMSRecordLoc(iDatastore, recID);
				break;
			} //else, not enough space in recordstore for record
		}

		if (newID == null) {
			logSpill(info.numDataStores, "attempting spill-over", true);
			RMS rs = newDataStore(info);
			if (rs != null) {
				iDatastore = info.numDataStores - 1;
				int recID = rs.addRecord(data);
				if (recID != -1) {
					logSpill(iDatastore, "success", true);
					newID = new RMSRecordLoc(iDatastore, recID);
				} else {
					logSpill(iDatastore, "spillover write failed", false);
					//not enough space in spillover RMS to store new record
					//remove newly-created spillover RMS so it's not lying around empty
					removeLastDataStore(info);
				}
			} else {
				//could not create spillover recordstore; entire RMS system is full
				logSpill(info.numDataStores, "failed to create spillover", false);
			}
		}
		
		return newID;
	}

	private void logSpill (int dataStoreNum, String msg, boolean ignoreForFirst) {
		if (!ignoreForFirst || dataStoreNum > 0) {
			log("rms-spill", "#" + dataStoreNum + " " + msg);
		}
	}
	
	/**
	 * Update a record in the data stores. It always tries to add a new record with the updated data, and then delete the
	 * old record. This is because (on some phones, at least), the RMS gets completely hosed if you try to update a record
	 * in place and there isn't enough space.
	 * 
	 * @param curLoc current location (RMS #, record ID) of the record
	 * @param data serialized byte data for record
	 * @param info StorageUtility info record
	 * @return new location of the record; null if storage is full
	 */
	private RMSRecordLoc updateRecord (RMSRecordLoc curLoc, byte[] data, RMSStorageInfo info) {
		RMSRecordLoc newID = addRecord(data, info);
		if (newID != null) {
			getDataStore(curLoc.rmsID).removeRecord(curLoc.recID);
			return newID;
		} else {
			return null;
		}
	}
	
	/**
	 * Return a reference to the indexing/meta-data RMS. Should always access it through this function, as it will re-open
	 * the RMS if it was closed by another thread.
	 * 
	 * @return reference to index/meta-data RMS
	 */
	private RMS getIndexStore () {
		indexstore.ensureOpen();
		return indexstore;
	}
	
	/**
	 * Return a reference to one of the data RMSes. Data RMSes are loaded lazily, so will load it if it has not been
	 * previously loaded. Will also re-open it if closed by another thread.
	 * 
	 * @param i number of data store RMS to retrieve
	 * @return reference to data RMS
	 * @throws IllegalArgumentException if i is out of the range of existing data stores for this StorageUtility
	 */
	private RMS getDataStore (int i) {
		if (i < 0 || i >= datastores.length) {
			throw new IllegalArgumentException("Data store [" + i + "] out of range");
		}
		
		RMS data = datastores[i];
		if (data == null) {
			try {
				data = new RMS(dataStoreName(i), false);
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error opening data store " + i + "; " + rse.getMessage());
			}
			datastores[i] = data;
		} else {
			data.ensureOpen();
		}
		return data;
	}
	
	/**
	 * Create (and cache) a new data store RMS for spillover
	 * 
	 * @param info StorageUtility info record
	 * @return a reference to the new data store RMS, null if the entire device is full or max # of data stores exceeded
	 */
	private RMS newDataStore (RMSStorageInfo info) {
		if (info.numDataStores == MAX_DATA_STORES) {
			System.out.println("Warning: maximum number of data RMSes exceeded in StorageUtility [" + basename + "]; repacking the StorageUtility may reclaim space and allow more records to be added");
			return null;
		}
		
		RMS rs = null;
		try {
			rs = new RMS(dataStoreName(info.numDataStores), true);
		} catch (RecordStoreFullException e) {
			return null;
		} catch (RecordStoreException e) {
			throw new RuntimeException("Error creating spillover datastore; " + e.getMessage());
		}

		//rs must not be null at this point
		try {
			if (rs.rms.getNumRecords() != 0) {
				logSpill(info.numDataStores, "spillover store not empty!", false);

				//attempt to clear it out
				try {
					Vector<Integer> IDs = new Vector<Integer>();
					for (RecordEnumeration re = rs.rms.enumerateRecords(null, null, false); re.hasNextElement(); ) {
						IDs.addElement(new Integer(re.nextRecordId()));
					}
					for (int i = 0; i < IDs.size(); i++) {
						rs.rms.deleteRecord(IDs.elementAt(i).intValue());
					}
				} catch (RecordStoreException rse) {
					logSpill(info.numDataStores, "error emptying out new data store: " + WrappedException.printException(rse), false);
				}
			}
		} catch (RecordStoreNotOpenException e) {
			throw new RuntimeException("can't happen");
		}
	
		info.numDataStores++;
		resizeDatastoreArray(info);		
		datastores[info.numDataStores - 1] = rs;
			
		return rs;
	}
	
	/**
	 * Remove and destroy the most-recently created (highest numbered) data store RMS. RMS must be empty.
	 * 
	 * @param info StorageUtility info record
	 */
	private void removeLastDataStore (RMSStorageInfo info) {
		int i = info.numDataStores - 1;
		RMS rs = getDataStore(i);
		
		try {
			if (rs.rms.getNumRecords() != 0) {
				throw new IllegalStateException("Attempted to remove a datastore that is not empty!");
			}
		} catch (RecordStoreNotOpenException e) {
			throw new RuntimeException("can't happen");
		}
		
		rs.close();
		try {
			RecordStore.deleteRecordStore(rs.name);
		} catch (RecordStoreNotFoundException e) {
			throw new RuntimeException("Programmer logic error");
		} catch (RecordStoreException e) {
			throw new RuntimeException("Error deleting datastore");
		}
		
		info.numDataStores--;
		resizeDatastoreArray(info);
	}
	
	/**
	 * Check the type of an object against the type registered for use with this StorageUtility. Print a warning
	 * if they differ (does not necessarily mean the two types are incompatible, but they probably are).
	 * 
	 * @param o new object
	 */
	private void typeCheck (Object o) {
		if (o.getClass() != type) {
			System.err.println("Warning: attempting to use type [" + o.getClass().getName() + "] with storage utility of type [" + type.getName() + "]; ensure their serializations are compatible!");
		}
	}
	
	/**
	 * Return the name of the indexing/meta-data RMS, constructed from this StorageUtility's base name
	 * 
	 * @return RMS name
	 */
	private String indexStoreName () {
		return basename + "_IX";
	}
	
	/**
	 * Return the name of one of the data store RMSes, constructed from this StoageUtility's base name
	 * 
	 * @param i number of data store
	 * @return RMS name
	 */
	private String dataStoreName (int i) {
		if (i < 0 || i >= MAX_DATA_STORES) {
			throw new IllegalArgumentException("Data stores can only be numbered 0 through " + MAX_DATA_STORES + " [" + i + "]");
		}
		return basename + "_" + DateUtils.intPad(i, 2);
	}
	
	/**
	 * Validate that the StorageUtility base name meets all requirements
	 * 
	 * @param basename base name of storage utility
	 */
	private void validateName (String basename) {
		if (basename.length() > MAX_RMS_NAME_LENGTH - SUFFIX_LENGTH) {
			throw new IllegalArgumentException("Cannot create storage utility. Utility base name [" + basename + "] exceeds J2ME length limits");
		}	
	}
	
	/**
	 * Validate that the record type for this StorageUtility meets all requirements
	 * 
	 * @param type Class object for the type of object this StorageUtility will handle
	 */
	private void validateDataType (Class type) {
		if (Externalizable.class.isAssignableFrom(type)) {
			try {
				PrototypeFactory.getInstance(type);
			} catch (CannotCreateObjectException ccoe) {
				throw new IllegalArgumentException("Cannot create storage utility. Type [" + type.getName() + "] cannot be used. (" + ccoe.getMessage() + ")");
			}
		} else {
			throw new IllegalArgumentException("Cannot create storage utility. Type [" + type.getName() + "] is not externalizable.");
		}		
	}
	
	/**
	 * Load the StorageUtility info record from the indexing/meta-data RMS
	 * 
	 * @return info record
	 */
	private RMSStorageInfo getInfoRecord () {
		RMSStorageInfo info = (RMSStorageInfo)getIndexStore().readRecord(STORAGE_INFO_REC_ID, RMSStorageInfo.class);
		
		if (info.numDataStores != datastores.length) {
			resizeDatastoreArray(info);
		}
		
		return info;
	}
	
	/**
	 * Commit the StorageUtility info record back to RMS
	 * 
	 * @param info info record
	 * @return true if record committed successfully; false if full
	 */
	private boolean writeInfoRecord (RMSStorageInfo info) {
		return getIndexStore().updateRecord(STORAGE_INFO_REC_ID, ExtUtil.serialize(info), true);
	}
	
	/**
	 * Resize the array of cached references to data store RMSes
	 * 
	 * @param info StorageUtility info record, from which the new number of data stores is taken
	 */
	private void resizeDatastoreArray (RMSStorageInfo info) {
		RMS[] old = datastores;
		datastores = new RMS[info.numDataStores];
		System.arraycopy(old, 0, datastores, 0, Math.min(old.length, datastores.length));
	}
	
	/**
	 * Load the ID index from the indexing/meta-data RMS
	 * 
	 * @return index hashtable, which maps integer record ID -> record locator
	 */
	public Hashtable getIDIndexRecord () {
		return (Hashtable)getIndexStore().readRecord(ID_INDEX_REC_ID, new ExtWrapMap(Integer.class, RMSRecordLoc.class));		
	}
	
	/**
	 * Commit the record ID index back to RMS
	 * 
	 * @param idIndex record ID index
	 * @return true if record committed successfully; false if full
	 */
	private boolean writeIDIndexRecord (Hashtable idIndex) {
		return getIndexStore().updateRecord(ID_INDEX_REC_ID, ExtUtil.serialize(new ExtWrapMap(idIndex)), true);
	}
	
	/**
	 * Reserve bytes for later usage. If 'size' is greater than zero, that amount of bytes plus a fixed 'safety margin'
	 * will be reserved (i.e., allocated into a designated record). If 'size' is zero, all reserved bytes will be released,
	 * including the safety margin (i.e., the designated record is resized to the minimum possible size).
	 * 
	 * @param size number of bytes to reserve (or 0 to release)
	 * @return true if bytes were allocated successfully; false if full
	 */
	private boolean setReserveBuffer (int size) {
		int bufsize = (size <= 0 ? 1 : size + RESERVE_BUFFER_SIZE);
		return getIndexStore().updateRecord(RESERVE_BUFFER_REC_ID, new byte[bufsize], true);
	}
	
	private int getReserveBufferSize () {
		try {
			return getIndexStore().rms.getRecordSize(RESERVE_BUFFER_REC_ID);
		} catch (Exception e) {
			return -1;
		}
	}
	
	/**
	 * Check that the StorageUtility has been properly initialized. Throw an exception if it is not
	 */
	public void checkInitialized () {
		checkStatusOK(true);
	}
	
	/**
	 * Check that the StorageUtility is in an initialized, consistent, non-corrupt state. Throw an exception if it is not
	 * 
	 * If the StorageUtility was not properly initialized, this call will fail.
	 * If transactions on this StorageUtility are currently in progress (such as by other threads), or a past transaction
	 *   failed and did not properly clean itself up, this call will fail. 
	 */
	public void checkNotCorrupt () {
		checkStatusOK(false);
	}
	
	/**
	 * Check the status of the StorageUtility, throwing fatal exceptions if it is in a disallowed state.
	 *   UNINITIALIZED is always a disallowed state
	 *   CLEAN is always an allowed state
	 *   DIRTY is allowed or disallowed depending on the parameter 'dirtyOK'
	 * 
	 * @param dirtyOK if true, DIRTY is an allowed status; if false, the DIRTY status will cause a fatal exception
	 */
	private void checkStatusOK (boolean dirtyOK) {
		int status = getStatus();
		
		if (status == STATUS_DIRTY) {
			if (!dirtyOK) {
				throw new IllegalStateException("Storage utility [" + basename + "] is in a corrupted state. You must repair it before you can access it again");
			}
		} else if (status != STATUS_CLEAN) {
			throw new IllegalStateException("Storage utility [" + basename + "] was not initialized properly, is pointing at the wrong RMSes, or is otherwise seriously broken. You will likely have to delete it and start over.");			
		}
	}
	
	/**
	 * Fetch the StorageUtility status flag
	 * 
	 * @return status flag code
	 */
	private int getStatus () {
		Integer statusObj = null;
		try {
			statusObj = (Integer)getIndexStore().readRecord(TX_FLAG_REC_ID, Integer.class);
		} catch (RuntimeException re) {
			//do nothing
			System.err.println("RuntimeException while trying to read StorageUtility status flag; could be transient or could be a serious problem with RMS; " + re.getMessage());
		}
		return (statusObj != null ? statusObj.intValue() : STATUS_UNINITIALIZED);
	}
	
	/**
	 * Set the status to DIRTY, indicating a transaction is in progress. Checks first to see that the status is
	 * CLEAN, else throws a fatal exception.
	 */
	private void setDirty () {
		checkNotCorrupt();
		getIndexStore().updateRecord(TX_FLAG_REC_ID, ExtUtil.serialize(new Integer(STATUS_DIRTY)), true);			
	}
	
	/**
	 * Set the status to CLEAN, indicating any transaction is now complete, and the StorageUtility is in a consistent state.
	 */
	private void setClean () {
		getIndexStore().updateRecord(TX_FLAG_REC_ID, ExtUtil.serialize(new Integer(STATUS_CLEAN)), true);
	}
	
	/**
	 * A simple wrapper around an RMS RecordStore that handles common exceptions and provides extra services like
	 * automatically opening/closing the RecordStore to free up space.
	 */
	private class RMS {
		public RecordStore rms;		//the RecordStore object being wrapped
		public String name;			//the name of this RecordStore
		
		/**
		 * Open/create an RMS and wrap it
		 * 
		 * @param name name of the RMS
		 * @param create if true, create the RMS if it does not exist
		 * @throws RecordStoreException any exception from openRecordStore() is passed on transparently
		 */
		public RMS (String name, boolean create) throws RecordStoreException {
			this.name = name;
			this.rms = RecordStore.openRecordStore(name, create);
		}
		
		public int addRecord (byte[] data) {
			return addRecord(data, false);
		}
		
		/**
		 * Simple wrapper for RecordStore.addRecord().
		 * 
		 * Optionally, if, on first attempt, RecordStore is full, it will close/reopen the record store to free up
		 * any available space, then try once more. (This may have a hefty performance penalty)
		 * 
		 * @param data record to add
		 * @param tryHard if true, will close/reopen the record store on a 'full' error and try again
		 * @return id of added record; -1 if full and no record was added
		 */
		public int addRecord (byte[] data, boolean tryHard) {
			try {
				int id = -1;
				
				try {
					id = rms.addRecord(data, 0, data.length);
				} catch (RecordStoreFullException rsfe) {
					//do nothing
				}
				
				if (id == -1 && tryHard) {
					cycle();
					try {
						id = rms.addRecord(data, 0, data.length);
					} catch (RecordStoreFullException rsfe2) {
						//do nothing
					}
				}
				
				return id;
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error adding record to RMS; " + rse.getMessage());
			}
		}
		
		public boolean updateRecord (int id, byte[] data) {
			return updateRecord(id, data, false);
		}
		
		/**
		 * Simple wrapper for RecordStore.updateRecord().
		 * 
		 * Optionally, if, on first attempt, RecordStore is full, it will close/reopen the record store to free up
		 * any available space, then try once more. (This may have a hefty performance penalty)
		 * 
		 * BUG: on the Nokia 6085 (and probably others, the RMS becomes hosed if you try to update a record and run
		 * out of space, so 'tryHard' will not save you here
		 * 
		 * Error if no record for 'id' exists
		 * 
		 * @param id id of record to update
		 * @param data updated record data
		 * @param tryHard if true, will close/reopen the record store on a 'full' error and try again
		 * @return true if the record was updated; false if full
		 */
		public boolean updateRecord (int id, byte[] data, boolean tryHard) {
			try {
				boolean success = false;
				
				try {
					rms.setRecord(id, data, 0, data.length);
					success = true;
				} catch (RecordStoreFullException rsfe) {
					//do nothing
				}
				
				if (!success && tryHard) {
					cycle();
					try {
						rms.setRecord(id, data, 0, data.length);
						success = true;
					} catch (RecordStoreFullException rsfe2) {
						//do nothing
					}
				}
				
				return success;
			} catch (InvalidRecordIDException e) {
				throw new RuntimeException("Attempted to update a record that does not exist [" + id + "]");
			} catch (RecordStoreException e) {
				throw new RuntimeException("Error updating record in RMS; " + e.getMessage());
			}
		}
		
		/**
		 * Return the byte data for a record.
		 * 
		 * @param id record ID
		 * @return byte array of record's data; null if no record exists for that ID
		 */
		public byte[] readRecord (int id) {
			try {
				return rms.getRecord(id);
			} catch (InvalidRecordIDException iride) {
				return null;
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error reading record from RMS; " + rse.getMessage());			
			}
		}
		
		/**
		 * Return a deserialized record object
		 * 
		 * @param id record ID
		 * @param type object type of record
		 * @return record object; null if no record exists for that ID
		 */
		public Object readRecord (int id, Class type) {
			byte[] data = readRecord(id);
			try {
				return (data != null ? ExtUtil.deserialize(data, type) : null); //technically loses information for 'Nullable's
			} catch (DeserializationException de) {
				throw new RuntimeException("Error deserializing bytestream for type [" + type.getName() + "]; " + de.getMessage());
			}
		}
		
		/**
		 * Return a deserialized record object
		 * 
		 * @param id record ID
		 * @param ew ExternalizableWrapper for record type (should not use ExtWrapNull(...), as you can't distinguish the record's
		 *    data being null from null as meaning record-not-found)
		 * @return record object; null if no record exists for that ID
		 */
		public Object readRecord (int id, ExternalizableWrapper ew) {
			byte[] data = readRecord(id);
			try {
				return (data != null ? ExtUtil.deserialize(data, ew) : null);
			} catch (DeserializationException de) {
				throw new RuntimeException("Error deserializing bytestream; " + de.getMessage());
			}
		}
		
		/**
		 * Remove a record. Error if record does not exist
		 * 
		 * @param id record ID to remove
		 */
		public void removeRecord (int id) {
			try {
				rms.deleteRecord(id);
			} catch (InvalidRecordIDException e) {
				throw new RuntimeException("Attempted to remove a record that does not exist [" + id + "]");
			} catch (RecordStoreException e) {
				throw new RuntimeException("Error removing record from RMS; " + e.getMessage());
			}
		}
		
		/**
		 * Close this record store.
		 * 
		 * It will call closeRecordStore() as many times as necessary to ensure the record store is closed (this is
		 * necessary as, if the record store has been opened and never closed by other threads/StorageUtilities, our
		 * attempts to close it will have no effect; there must be one call to closeRecordStore() for each call to
		 * openRecordStore() for the record store to be truly closed).
		 */
		public void close () {
			boolean closed = false;
			
			while (!closed) {
				try {
					rms.closeRecordStore();
				} catch (RecordStoreNotOpenException e) {
					closed = true;
				} catch (RecordStoreException e) {
					throw new RuntimeException("Error closing recordstore");
				}
			}
		}
		
		/**
		 * Check that the record store is open, and reopen it if not. (It may have been closed by other threads or
		 * StorageUtilitys)
		 */
		public void ensureOpen () {
			try {
				rms.getName(); //presumably the simplest operation that will trigger a 'not open' exception
			} catch (RecordStoreNotOpenException e) {
				try {
					rms = RecordStore.openRecordStore(name, false);
				} catch (RecordStoreException e1) {
					throw new RuntimeException("error");
				}
			}
		}
		
		/**
		 * Forcibly close and re-open the record store, to trigger reclamation of any unused space.
		 */
		public void cycle () {
			try {
				close();
				rms = RecordStore.openRecordStore(name, false);
			} catch (RecordStoreException e) {
				throw new RuntimeException("error cycling recordstore");
			}
		}
	}
	
	/**
	 * Create an entry for this StorageUtility (unique to this utility's base name) in the static table of synchronization
	 * objects.
	 */
	private void initStaticInfo () {
		synchronized (storageStaticInfo) {
			if (!storageStaticInfo.containsKey(basename)) {
				storageStaticInfo.put(basename, new StorageStaticEntity());
			}
		}
	}
	
	/**
	 * Fetch the object that acts as the synchronization lock for this StorageUtility
	 * 
	 * @return lock object
	 */
	public Object getAccessLock () {
		synchronized (storageStaticInfo) {
			return ((StorageStaticEntity)storageStaticInfo.get(basename)).lock;
		}
	}
	
	/**
	 * Create a new record iterator and register it
	 * 
	 * @param IDs list of record IDs to iterate over
	 * @return record iterator
	 */
	private RMSStorageIterator newIterator (Vector IDs) {
		RMSStorageIterator iter = new RMSStorageIterator(this, IDs);
		
		synchronized (storageStaticInfo) {
			((StorageStaticEntity)storageStaticInfo.get(basename)).iterators.addElement(iter);
		}
		
		return iter;
	}
	
	/**
	 * Callback from iterator when its iteration is complete
	 * 
	 * @param iter iterator making the callback
	 */
	public void iteratorComplete (RMSStorageIterator iter) {
		synchronized (storageStaticInfo) {
			((StorageStaticEntity)storageStaticInfo.get(basename)).iterators.removeElement(iter);
		}
	}	
	
	/**
	 * When this StorageUtility has been modified (record add/update/remove), this will invalidate and
	 * unregister all active iterators
	 */
	private void invalidateIterators () {
		synchronized (storageStaticInfo) {
			Vector iterators = ((StorageStaticEntity)storageStaticInfo.get(basename)).iterators;
			
			for (int i = 0; i < iterators.size(); i++) {
				((RMSStorageIterator)iterators.elementAt(i)).invalidate();
			}
			
			iterators.removeAllElements();
		}
	}
	
	/**
	 * Stores objects that need to be maintained per storage entity (meaning, per unique basename). Multiple StorageUtilitys
	 * can be instantiated at once with the same basename, so this shared object is necessary.
	 */
	private class StorageStaticEntity {
		public Object lock;					//synchronization lock for this storage
		public Vector iterators;			//list of active record enumerations over this storage
		
		public StorageStaticEntity () {
			lock = new Object();
			iterators = new Vector();
		}
	}

	private void txRecord (int recordID, String opType) {
		RMSTransaction tx = RMSTransaction.getTx();
		if (tx == null) { //no active transaction
			return;
		}
		
		if (!tx.isRecordTouched(getName(), recordID)) {
			try {
				RMSStorageUtility tx_cache = new RMSStorageUtility(RMSTransaction.CACHE_RMS, TxCacheEntry.class);
				boolean recordExists = !"add".equals(opType);
				int entry_id = tx_cache.add(new TxCacheEntry(tx, this, recordID, recordExists));
				tx.recordTouched(getName(), recordID, entry_id);
			} catch (Exception e) {
				throw new WrappedException("RMS transaction error; could not back up original state of record; original operation [" + opType + "] aborted because transaction guarantees cannot be met", e);
			}
		}
	}	
	
	/* ========== DEBUGGING CODE ============ */
	
	public String debugInfo () {
		StringBuffer sb = new StringBuffer();
		sb.append("=================\n");
		
		RMSStorageInfo info = getInfoRecord();
		Hashtable ix = getIDIndexRecord();
		
		sb.append(basename + "(" + type.getName() + ") -- " + getStatus() + "\n");
		sb.append(info.numRecords + ":" + info.numDataStores + ":" + info.nextRecordID + "\n");
		
		sb.append("rec index:\n");
		for (Enumeration e = ix.keys(); e.hasMoreElements(); ) {
			int id = ((Integer)e.nextElement()).intValue();
			RMSRecordLoc loc = (RMSRecordLoc)ix.get(new Integer(id));
			sb.append("  " + id + " => (" + loc.rmsID + ", " + loc.recID + ")\n");
		}
		
		sb.append(printRMSInfo(getIndexStore().rms));
		for (int i = 0; i < info.numDataStores; i++) {
			sb.append(printRMSInfo(getDataStore(i).rms));
		}
		
		sb.append("\n");
		return sb.toString();
	}
	
	private String printRMSInfo (RecordStore rs) {
		StringBuffer sb = new StringBuffer();
		try {
			sb.append("RMS: " + rs.getName() + " [" + rs.getNumRecords() + "]\n");
			for (RecordEnumeration e = rs.enumerateRecords(null, null, false); e.hasNextElement(); ) {
				int id = e.nextRecordId();
				sb.append("  " + id + " => [" + rs.getRecordSize(id) + "]\n");
			}
		} catch (RecordStoreException e) {
			sb.append("RecordStoreException! " + e.getClass().getName() + " " + e.getMessage() + "\n");
		}
		return sb.toString();
	}

	public Element getStatusReport() throws StatusReportException {
		Element storage = new Element();
		storage.setName("storage_utility");
		storage.setAttribute(null, "name",this.getName());
		
		
		Element total = storage.createElement(null, "total_records");
		total.addChild(Element.TEXT,getNumRecords() + "");
		storage.addChild(Element.ELEMENT, total);
		
		Element size = storage.createElement(null, "total_size");
		size.addChild(Element.TEXT,getTotalSize() + "");
		storage.addChild(Element.ELEMENT, size);
		
		Element status = storage.createElement(null, "status_flag");
		String statusText;
		int statusFlag = getStatus();
		switch(statusFlag) {
			case STATUS_CLEAN: statusText = "CLEAN"; break;
			case STATUS_DIRTY: statusText = "DIRTY"; break;
			case STATUS_UNINITIALIZED: statusText = "UNINITIALIZED"; break;
			default: statusText = "UNKNOWN: " + statusFlag; break;
		}
		status.addChild(Element.TEXT, statusText);
		storage.addChild(Element.ELEMENT, status);
		
		RMSStorageInfo info = getInfoRecord();

		for (int i = 0; i < info.numDataStores; i++) {
			RMS rmsStore = getDataStore(i);
			
			Element store = storage.createElement(null,"rms_store");
			store.setAttribute(null,"name", rmsStore.name);
			store.setAttribute(null,"index",i + "");
			
			try {
				Element storeRecords = storage.createElement(null,"num_records");
				storeRecords.addChild(Element.TEXT, rmsStore.rms.getNumRecords() + "");
				store.addChild(Element.ELEMENT,storeRecords);
				
				Element sizeUsed = storage.createElement(null,"size_used");
				sizeUsed.addChild(Element.TEXT, rmsStore.rms.getSize() + "");
				store.addChild(Element.ELEMENT,sizeUsed);
			
				Element sizeAvail = storage.createElement(null,"size_available");
				sizeAvail.addChild(Element.TEXT, rmsStore.rms.getSizeAvailable() + "");
				store.addChild(Element.ELEMENT,sizeAvail);
			} catch (RecordStoreNotOpenException e) {
				throw new StatusReportException(e, "storage_utility","Storage: " + this.getName() + " Record Store Not Open");
			}
			rmsStore.close();
			storage.addChild(Element.ELEMENT, store);
		}
		return storage;
	}
	
	public void log (String type, String message) {
		if (!LogEntry.STORAGE_KEY.equals(basename)) {
			Logger.log(type, basename + ": " + message);
		}
	}
}

