package org.javarosa.j2me.storage.rms;

import java.util.Hashtable;

import javax.microedition.rms.InvalidRecordIDException;
import javax.microedition.rms.RecordStore;
import javax.microedition.rms.RecordStoreException;
import javax.microedition.rms.RecordStoreFullException;
import javax.microedition.rms.RecordStoreNotFoundException;
import javax.microedition.rms.RecordStoreNotOpenException;

import org.javarosa.core.model.utils.DateUtils;
import org.javarosa.core.services.storage.Persistable;
import org.javarosa.core.services.storage.StorageFullException;
import org.javarosa.core.util.externalizable.CannotCreateObjectException;
import org.javarosa.core.util.externalizable.DeserializationException;
import org.javarosa.core.util.externalizable.ExtUtil;
import org.javarosa.core.util.externalizable.ExtWrapMap;
import org.javarosa.core.util.externalizable.Externalizable;
import org.javarosa.core.util.externalizable.ExternalizableWrapper;
import org.javarosa.core.util.externalizable.PrototypeFactory;

/**
 * class StorageUtility
 * 
 * This class provides a persistent record store, built on top of RMS. StorageUtility takes a name which uniquely
 * identifies it, and associates it with several underlying RMSes. Each StorageUtility is meant to store records
 * (objects) of a single type. Different StorageUtilitys can be instantiated (with different names) to handle
 * records/objects of different types.
 * 
 * Features of StorageUtility:
 *   * available storage is not limited by the size constraints of a single RMS; records will spill over into
 *     additional RMSes as needed
 *   * records can have their own ID numbers independent of the ID numbers generated by RMS
 *   * access is completely thread-safe
 *   * recover gracefully from RMS errors, particularly RMS full. tries hard to not leave the storage structure in
 *     an inconsistent state, and if it is, you'll at least know about it
 * 
 * StorageUtility can be used in two flavors: you manage the IDs, or the utility manages the IDs:
 * 
 * If you manage the IDs, the objects you are storing must implement Persistable, which provides the ID from the object
 * itself. You then use the functions read(), write(), and remove() when dealing with storage.
 * 
 * If the utility manages the IDs, your objects need only implement Externalizable. You use the functions read(), add(),
 * update(), and remove(). add() will return a new ID for the record, which you then explicitly provide to all subsequent
 * calls to update().
 * 
 * These two schemes should not be mixed within the same StorageUtility.
 * 
 */
public class RMSStorageUtility {
	private static final int MAX_RMS_NAME_LENGTH = 32;		//maximum length of an RMS name
	private static final int SUFFIX_LENGTH = 3;				//how much of RMS name that we need to reserve for our own purposes
	
	/* hard-coded ID numbers of specific records in the indexing RMS */
	private static final int TX_FLAG_REC_ID = 1;			//status flag
	private static final int STORAGE_INFO_REC_ID = 2;		//general info (# records, # data stores, etc.)
	private static final int ID_INDEX_REC_ID = 3;			//record ID -> record location index
	private static final int RESERVE_BUFFER_REC_ID = 4;		//safety buffer
	
	/* amount of safety buffer we want to keep for unexpected size increases to our indexing structures. this is important as
	 * we don't support rolling back updates to the data records. if we successfully change the data, but don't have enough
	 * space to update the indexes, the StorageUtility will become corrupt! (which can be repaired, but may result in data loss
	 * for the record most recently touched
	 */
	private static final int RESERVE_BUFFER_SIZE = 400;
	
	/* statuses that the StorageUtility may have */
	private static final int STATUS_UNINITIALIZED = -1;		/* StorageUtility still being initialized and not ready for action
															   will only be seen in the wild if the constructor failed */
	private static final int STATUS_CLEAN = 0;				/* StorageUtility is in a consistent state and ready for action */
	private static final int STATUS_DIRTY = 1;				/* StorageUtility is in an inconsistent state, meaning some sort of
															   transaction is in progress, or the previous transaction failed
															   in a way we could not recover from (meaning the StorageUtility
															   must be repaired before it can be used again) */
	
	/* static collection of synchronization locks (one per unique StorageUtility name) */
	private static Hashtable accessLocks = new Hashtable();
	
	private String basename;		//unique name identifying this collection of records
	private Class type;				//type of object this StorageUtility stores
	
	private RMS indexstore;			//RMS wrapper for the indexing RMS
	private RMS[] datastores;		//RMS wrappers for 1..n data RMSes (are loaded as needed, so entries may be null)
	
	/**
	 * Instantiate a new StorageUtility. Will create the underlying skeleton RMSes if they don't exist
	 * 
	 * @param basename unique name identifying this StorageUtility. Different collections of the same type of object
	 *   can be kept distinct by giving their StorageUtilitys different names (e.g., "PATIENTS" and "DEMO_PATIENTS")
	 * @param type object type that this StorageUtility stores and retrieves. this class must implement Externalizable
	 */
	public RMSStorageUtility (String basename, Class type) {
		validateName(basename);
		validateDataType(type);
		
		this.basename = basename;
		this.type = type;

		initAccessLock();
			
		loadIndexStore();
	}
	
	/**
	 * Read and return the record corresponding to 'id'.
	 * 
	 * @param id id of the object
	 * @return object for 'id'. null if no object is stored under that ID
	 */
	public Externalizable read (int id) {
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			if (idIndex.containsKey(new Integer(id))) {
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				return (Externalizable)getDataStore(loc.rmsID).readRecord(loc.recID, type);
			} else {
				return null;
			}
			
		}
	}

	/**
	 * Read and return the raw bytes for the record corresponding to 'id'.
	 * 
	 * @param id id of the object
	 * @return raw bytes for the record. null if no record is stored under that ID
	 */
	public byte[] readBytes (int id) {
		synchronized (getAccessLock()) {
			
			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			if (idIndex.containsKey(new Integer(id))) {
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				return getDataStore(loc.rmsID).readRecord(loc.recID);
			} else {
				return null;
			}
			
		}		
	}
	
	/**
	 * Write an object to the store. Will either add a new record, or update the existing record (if one exists) for the
	 * object's ID. This function should never be used in conjunction with add() and update() within the same StorageUtility
	 * 
	 * @param p object to store
	 * @throws StorageFullException if there is not enough room to store the object
	 */
	public void write (Persistable p) throws StorageFullException {
		typeCheck(p);
		
		int id = p.getID();
		byte[] data = ExtUtil.serialize(p);
		
		RMSRecordLoc newLoc = null;
		boolean updateIndex = false;
		boolean full = false;

		synchronized (getAccessLock()) {
			Hashtable idIndex = getIDIndexRecord();
			RMSStorageInfo info = getInfoRecord();

			setDirty();
			
			boolean recordExists = idIndex.containsKey(new Integer(id));

			//reserve space for updating index/metadata
			int bytesNeededEstimate = (recordExists ? 20 : 40);
			if (!setReserveBuffer(bytesNeededEstimate)) {
				setClean();
				//can't reserve needed space to update index
				throw new StorageFullException();
			}
			
			if (recordExists) {
				RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
				newLoc = updateRecord(loc, data, info);

				if (newLoc == null) {
					full = true;
				} else if (!newLoc.equals(loc)) {
					updateIndex = true;
				}
			} else {
				newLoc = addRecord(data, info);
				
				if (newLoc == null) {
					full = true;
				} else {
					info.numRecords++;
					updateIndex = true;
				}
			}
			
			//release the space we reserved
			setReserveBuffer(0);
			
			if (full) {
				setClean();
				throw new StorageFullException();
			} else if (updateIndex) {
				idIndex.put(new Integer(id), newLoc);
				
				commitIndex(info, idIndex);
				setClean();
			}
		}
	}
	
	/**
	 * Add a new record to the store. This function always adds a new record; it never updates an existing record. The
	 * record ID under which this record is added is allocated by the StorageUtility. If this StorageUtility stores
	 * Persistables, you should almost certainly use write() instead.
	 * 
	 * @param e object to add
	 * @return record ID for newly added object
	 * @throws StorageFullException if not enough space available
	 */
	public int add (Externalizable e) throws StorageFullException {
		typeCheck(e);
		
		byte[] data = ExtUtil.serialize(e);

		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();
			int id = info.nextRecordID;
			info.nextRecordID++;
			
			setDirty();
			
			//reserve space for updating index/metadata
			int bytesNeededEstimate = 40;
			if (!setReserveBuffer(bytesNeededEstimate)) {
				setClean();
				//can't reserve needed space to update index
				throw new StorageFullException();
			}
			
			RMSRecordLoc loc = addRecord(data, info);
			
			//release the space we reserved
			setReserveBuffer(0);
						
			if (loc == null) {
				setClean();
				throw new StorageFullException();
			}
			
			Hashtable idIndex = getIDIndexRecord();
			idIndex.put(new Integer(id), loc);
			info.numRecords++;
			
			commitIndex(info, idIndex);
			setClean();
			
			return id;
		}	
	}
	
	/**
	 * Update a record in the store. The record must have previously been added to the store using add(). If this
	 * StorageUtility stores Persistables, you should almost certainly use write() instead.
	 * 
	 * @param id ID of record to update
	 * @param e updated object
	 * @throws StorageFullException if not enough space available to update
	 * @throws IllegalArgumentException if no record exists for ID
	 */
	public void update (int id, Externalizable e) throws StorageFullException {
		typeCheck(e);
		
		byte[] data = ExtUtil.serialize(e);
		
		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();
			Hashtable idIndex = getIDIndexRecord();
			if (!idIndex.containsKey(new Integer(id))) {
				throw new IllegalArgumentException("Record ID [" + id + "] not found");
			}
	
			setDirty();
			
			//reserve space for updating index/metadata
			int bytesNeededEstimate = 20;
			if (!setReserveBuffer(bytesNeededEstimate)) {
				setClean();
				//can't reserve needed space to update index
				throw new StorageFullException();
			}
			
			RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
			RMSRecordLoc newLoc = updateRecord(loc, data, info);
	
			//release the space we reserved
			setReserveBuffer(0);
			
			if (newLoc == null) {
				setClean();
				throw new StorageFullException();
			} else if (!newLoc.equals(loc)) {
				idIndex.put(new Integer(id), newLoc);
				commitIndex(info, idIndex);
			}
			setClean();
		}
	}
	
	/**
	 * Remove record with the given ID from the store.
	 * 
	 * @param id ID of record to remove
	 * @throws IllegalArgumentException if no record with that ID exists
	 */
	public void remove (int id) {
		synchronized (getAccessLock()) {
			RMSStorageInfo info = getInfoRecord();
			Hashtable idIndex = getIDIndexRecord();
			if (!idIndex.containsKey(new Integer(id))) {
				throw new IllegalArgumentException("Record ID [" + id + "] not found");
			}
	
			setDirty();
						
			RMSRecordLoc loc = (RMSRecordLoc)idIndex.get(new Integer(id));
			getDataStore(loc.rmsID).removeRecord(loc.recID);
			
			info.numRecords--;
			idIndex.remove(new Integer(id));
			commitIndex(info, idIndex);
			setClean();
		}
	}
	
	/**
	 * Remove object from the store
	 * 
	 * @param p object to remove
	 * @throws IllegalArgumentException if object is not in the store
	 */
	public void remove (Persistable p) {
		typeCheck(p);
		
		remove(p.getID());
	}

	/**
	 * Return the number of records in the store
	 * 
	 * @return number of records
	 */
	public int getNumRecords () {
		synchronized (getAccessLock()) {

			checkNotCorrupt();			

			return getInfoRecord().numRecords;

		}
	}

	/**
	 * Return whether the store is empty
	 * 
	 * @return true if there are no records in the store
	 */
	public boolean isEmpty () {
		return getNumRecords() == 0;
	}
	
	/**
	 * Return whether a record exists in the store
	 *
	 * @param id record ID
	 * @return true if a record exists for that ID in the store
	 */
	public boolean exists (int id) {
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			Hashtable idIndex = getIDIndexRecord();
			return idIndex.containsKey(new Integer(id));
			
		}
	}
	
	/**
	 * Return total size used by this StorageUtility, including all underlying RMSes
	 *
	 * @return total size (bytes)
	 */
	public int getTotalSize () {
		int size = 0;
		
		synchronized (getAccessLock()) {

			checkNotCorrupt();
			
			RMSStorageInfo info = getInfoRecord();
			
			try {
				size += getIndexStore().rms.getSize();
				for (int i = 0; i < info.numDataStores; i++) {
					size += getDataStore(i).rms.getSize();
				}
			} catch (RecordStoreNotOpenException e) {
				throw new RuntimeException("can't happen");
			}
		}
		
		return size;
	}
	
	/**
	 * Get the size of a record
	 * 
	 * @param id record ID
	 * @return size of that record, in bytes
	 * @throws IllegalArgumentException if no record exists for that ID
	 */
	public int getRecordSize (int id) {
		throw new RuntimeException("not implemented yet");
	}
	
	/**
	 * Attempt to commit all changes to the indexing and meta-data structures after a record operation (add/update/remove) has been
	 * done. Throw a fatal exception if any of these commits fail. It is the responsibility of the caller to ensure that there is
	 * enough space to write these updates (such as by reserving a 'safety buffer' of bytes then releasing it immediately prior to
	 * this call). We have no provision for rolling back record changes (add/update/remove), so if these commits fail, the
	 * StorageUtility will be left in a corrupt state, necessitating repair (which in turn may result in data loss). So it is 
	 * important to reserve the necessary space.
	 * 
	 * @param info general StorageUtility info record
	 * @param idIndex ID -> record location mapping
	 */
	private void commitIndex (RMSStorageInfo info, Hashtable idIndex) {
		boolean failed = false;

		if (!failed)
			failed = !writeIDIndexRecord(idIndex);
		if (!failed)
			failed = !writeInfoRecord(info);

		if (failed) {
			System.err.println("We weren't able to commit the updated index and meta-data, even though we thought we had enough space! The utility is now corrupt!!");
			throw new RuntimeException("ERROR! Enable to complete action! Utility must be repaired!");
		}
	}
	
	/**
	 * Close all resources associated with this StorageUtility. Any attempt to use this StorageUtility after this call will result
	 * in error. Though not strictly necessary, it is a good idea to call this when you are done with the StorageUtility, as closing
	 * may trigger clean-up in the underlying RMSes (device-dependent behavior) which may reclaim unused space.
	 * 
	 * Don't worry about other StorageUtilitys that reference the same data (such as in other threads); they will reopen their
	 * RecordStores as needed.
	 */
	public void close () {
		synchronized (getAccessLock()) {
			indexstore.close();
			indexstore = null;

			for (int i = 0; i < datastores.length; i++) {
				if (datastores[i] != null) {
					datastores[i].close();
				}
			}
			datastores = null;
		}
	}
	
	/**
	 * Load the indexing/meta-data RMS when this StorageUtility is first instantiated, and check its integrity. Create
	 * it if it doesn't exist. 
	 */
	private void loadIndexStore () {
		synchronized (getAccessLock()) {
			
			RMS ix = null;
			try {
				ix = new RMS(indexStoreName(), false);
			} catch (RecordStoreNotFoundException rsnfe) {
				//do nothing; will create record store next
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error opening index record: " + rse.getMessage());
			}
			
			if (ix == null) {
				ix = initIndexStore();
			}
			
			checkInitialized();
			
			this.indexstore = ix;
			this.datastores = new RMS[0];
			getInfoRecord();

		}
	}
	
	/**
	 * Create a new indexing/meta-data RMS. The RMS must not exist already.
	 *  
	 * @return a reference to the RMS
	 */
	private RMS initIndexStore () {
		RMS ix = null;
		try {
			ix = new RMS(indexStoreName(), true);
		} catch (RecordStoreException rse) {
			throw new RuntimeException("Error creating index record: " + rse.getMessage());
		}
		
		int recID;
		
		//initialize status flag
		recID = ix.addRecord(ExtUtil.serialize(new Integer(STATUS_UNINITIALIZED)));
		if (recID != TX_FLAG_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		//create default storage info
		recID = ix.addRecord(ExtUtil.serialize(new RMSStorageInfo()));
		if (recID != STORAGE_INFO_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		//create empty record ID index
		recID = ix.addRecord(ExtUtil.serialize(new ExtWrapMap(new Hashtable())));
		if (recID != ID_INDEX_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		//create buffer of reserve bytes
		recID = ix.addRecord(new byte[1]); //RMS has trouble with zero-length records
		if (recID != RESERVE_BUFFER_REC_ID) {
			throw new RuntimeException("Error building meta RMS: record not assigned to expected ID");
		}
		
		setClean();
		
		return ix;
	}
	
	/**
	 * Add a new record to the data stores. Attempts to add the record to each data store, starting with the lowest,
	 * until it finds a data store that is not full and successfully accepts the record. If all data stores are full,
	 * attempt to spillover by creating and adding to an additional data store.
	 * 
	 * If a spillover data store is created, but does not have enough space for the record, the new (empty) data store is removed
	 * 
	 * @param data serialized byte data for record
	 * @param info StorageUtility info record
	 * @return location record was added to (RMS #, record ID); null if storage is full
	 */
	private RMSRecordLoc addRecord (byte[] data, RMSStorageInfo info) {
		RMSRecordLoc newID = null;
		int iDatastore;
		
		for (iDatastore = 0; iDatastore < info.numDataStores; iDatastore++) {
			RMS rs = getDataStore(iDatastore);
			int recID = rs.addRecord(data);
			if (recID != -1) {
				newID = new RMSRecordLoc(iDatastore, recID);
				break;
			} //else, not enough space in recordstore for record
		}
		
		if (newID == null) {
			RMS rs = newDataStore(info);
			if (rs != null) {
				iDatastore = info.numDataStores - 1;
				
				int recID = rs.addRecord(data);
				if (recID != -1) {
					newID = new RMSRecordLoc(iDatastore, recID);
				} else {
					//not enough space in spillover RMS to store new record
					//remove newly-created spillover RMS so it's not lying around empty
					removeLastDataStore(info);
				}
			} //else, could not create spillover recordstore; entire RMS system is full
		}
		
		return newID;
	}

	/**
	 * Update a record in the data stores. First attempt to update it in place. If the size of the record has increased too
	 * much and it no longer fits in its current RMS, add the updated record to a different RMS using the algorithm from
	 * addRecord(), and then delete the old record from the original RMS.
	 * 
	 * @param curLoc current location (RMS #, record ID) of the record
	 * @param data serialized byte data for record
	 * @param info StorageUtility info record
	 * @return final location of the record (will be same as curLoc if record was updated in place); null if storage is full
	 */
	private RMSRecordLoc updateRecord (RMSRecordLoc curLoc, byte[] data, RMSStorageInfo info) {
		RMS rs = getDataStore(curLoc.rmsID);
		boolean updated = rs.updateRecord(curLoc.recID, data);
		if (updated) {
			return curLoc;
		} else {
			RMSRecordLoc newID = addRecord(data, info);
			if (newID != null) {
				rs.removeRecord(curLoc.recID);
				return newID;
			} else {
				return null;
			}
		}
	}
	
	/**
	 * Return a reference to the indexing/meta-data RMS. Should always access it through this function, as it will re-open
	 * the RMS if it was closed by another thread.
	 * 
	 * @return reference to index/meta-data RMS
	 */
	private RMS getIndexStore () {
		indexstore.ensureOpen();
		return indexstore;
	}
	
	/**
	 * Return a reference to one of the data RMSes. Data RMSes are loaded lazily, so will load it if it has not been
	 * previously loaded. Will also re-open it if closed by another thread.
	 * 
	 * @param i number of data store RMS to retrieve
	 * @return reference to data RMS
	 * @throws IllegalArgumentException if i is out of the range of existing data stores for this StorageUtility
	 */
	private RMS getDataStore (int i) {
		if (i < 0 || i >= datastores.length) {
			throw new IllegalArgumentException("Data store [" + i + "] out of range");
		}
		
		RMS data = datastores[i];
		if (data == null) {
			try {
				data = new RMS(dataStoreName(i), false);
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error opening data store " + i + "; " + rse.getMessage());
			}
			datastores[i] = data;
		} else {
			data.ensureOpen();
		}
		return data;
	}
	
	/**
	 * Create (and cache) a new data store RMS for spillover
	 * 
	 * @param info StorageUtility info record
	 * @return a reference to the new data store RMS
	 */
	private RMS newDataStore (RMSStorageInfo info) {
		RMS rs = null;
		try {
			rs = new RMS(dataStoreName(info.numDataStores), true);
		} catch (RecordStoreFullException e) {
			return null;
		} catch (RecordStoreException e) {
			throw new RuntimeException("Error creating spillover datastore; " + e.getMessage());
		}
		
		try {
			if (rs.rms.getNumRecords() != 0) {
				throw new RuntimeException("Newly created datastore is not empty!");
			}
		} catch (RecordStoreNotOpenException e) {
			throw new RuntimeException("can't happen");
		}
		
		info.numDataStores++;
		resizeDatastoreArray(info);		
		datastores[info.numDataStores - 1] = rs;
		
		return rs;
	}
	
	/**
	 * Remove and destroy the most-recently created (highest numbered) data store RMS. RMS must be empty.
	 * 
	 * @param info StorageUtility info record
	 */
	private void removeLastDataStore (RMSStorageInfo info) {
		int i = info.numDataStores - 1;
		RMS rs = getDataStore(i);
		
		try {
			if (rs.rms.getNumRecords() != 0) {
				throw new IllegalStateException("Attempted to remove a datastore that is not empty!");
			}
		} catch (RecordStoreNotOpenException e) {
			throw new RuntimeException("can't happen");
		}
		
		rs.close();
		try {
			RecordStore.deleteRecordStore(rs.name);
		} catch (RecordStoreNotFoundException e) {
			throw new RuntimeException("Programmer logic error");
		} catch (RecordStoreException e) {
			throw new RuntimeException("Error deleting datastore");
		}
		
		info.numDataStores--;
		resizeDatastoreArray(info);
	}
	
	/**
	 * Check the type of an object against the type registered for use with this StorageUtility. Print a warning
	 * if they differ (does not necessarily mean the two types are incompatible, but they probably are).
	 * 
	 * @param o new object
	 */
	private void typeCheck (Object o) {
		if (o.getClass() != type) {
			System.err.println("Warning: attempting to use type [" + o.getClass().getName() + "] with storage utility of type [" + type.getName() + "]; ensure their serializations are compatible!");
		}
	}
	
	/**
	 * Return the name of the indexing/meta-data RMS, constructed from this StorageUtility's base name
	 * 
	 * @return RMS name
	 */
	private String indexStoreName () {
		return basename + "_IX";
	}
	
	/**
	 * Return the name of one of the data store RMSes, constructed from this StoageUtility's base name
	 * 
	 * @param i number of data store
	 * @return RMS name
	 */
	private String dataStoreName (int i) {
		if (i < 0 || i > 99) {
			throw new IllegalArgumentException("Data stores can only be numbered 0 through 99 [" + i + "]");
		}
		return basename + "_" + DateUtils.intPad(i, 2);
	}
	
	/**
	 * Validate that the StorageUtility base name meets all requirements
	 * 
	 * @param basename base name of storage utility
	 */
	private void validateName (String basename) {
		if (basename.length() > MAX_RMS_NAME_LENGTH - SUFFIX_LENGTH) {
			throw new IllegalArgumentException("Cannot create storage utility. Utility base name [" + basename + "] exceeds J2ME length limits");
		}	
	}
	
	/**
	 * Validate that the record type for this StorageUtility meets all requirements
	 * 
	 * @param type Class object for the type of object this StorageUtility will handle
	 */
	private void validateDataType (Class type) {
		if (Externalizable.class.isAssignableFrom(type)) {
			try {
				PrototypeFactory.getInstance(type);
			} catch (CannotCreateObjectException ccoe) {
				throw new IllegalArgumentException("Cannot create storage utility. Type [" + type.getName() + "] cannot be used. (" + ccoe.getMessage() + ")");
			}
		} else {
			throw new IllegalArgumentException("Cannot create storage utility. Type [" + type.getName() + "] is not externalizable.");
		}		
	}
	
	/**
	 * Load the StorageUtility info record from the indexing/meta-data RMS
	 * 
	 * @return info record
	 */
	private RMSStorageInfo getInfoRecord () {
		RMSStorageInfo info = (RMSStorageInfo)getIndexStore().readRecord(STORAGE_INFO_REC_ID, RMSStorageInfo.class);
		
		if (info.numDataStores != datastores.length) {
			resizeDatastoreArray(info);
		}
		
		return info;
	}
	
	/**
	 * Commit the StorageUtility info record back to RMS
	 * 
	 * @param info info record
	 * @return true if record committed successfully; false if full
	 */
	private boolean writeInfoRecord (RMSStorageInfo info) {
		return getIndexStore().updateRecord(STORAGE_INFO_REC_ID, ExtUtil.serialize(info));
	}
	
	/**
	 * Resize the array of cached references to data store RMSes
	 * 
	 * @param info StorageUtility info record, from which the new number of data stores is taken
	 */
	private void resizeDatastoreArray (RMSStorageInfo info) {
		RMS[] old = datastores;
		datastores = new RMS[info.numDataStores];
		System.arraycopy(old, 0, datastores, 0, Math.min(old.length, datastores.length));
	}
	
	/**
	 * Load the ID index from the indexing/meta-data RMS
	 * 
	 * @return index hashtable, which maps integer record ID -> record locator
	 */
	private Hashtable getIDIndexRecord () {
		return (Hashtable)getIndexStore().readRecord(ID_INDEX_REC_ID, new ExtWrapMap(Integer.class, RMSRecordLoc.class));		
	}
	
	/**
	 * Commit the record ID index back to RMS
	 * 
	 * @param idIndex record ID index
	 * @return true if record committed successfully; false if full
	 */
	private boolean writeIDIndexRecord (Hashtable idIndex) {
		return getIndexStore().updateRecord(ID_INDEX_REC_ID, ExtUtil.serialize(new ExtWrapMap(idIndex)));
	}
	
	/**
	 * Reserve bytes for later usage. If 'size' is greater than zero, that amount of bytes plus a fixed 'safety margin'
	 * will be reserved (i.e., allocated into a designated record). If 'size' is zero, all reserved bytes will be released,
	 * including the safety margin (i.e., the designated record is resized to the minimum possible size).
	 * 
	 * @param size number of bytes to reserve (or 0 to release)
	 * @return true if bytes were allocated successfully; false if full
	 */
	public boolean setReserveBuffer (int size) {
		int bufsize = (size <= 0 ? 1 : size + RESERVE_BUFFER_SIZE);
		return getIndexStore().updateRecord(RESERVE_BUFFER_REC_ID, new byte[bufsize]);
	}
	
	/**
	 * Create an entry for this StorageUtility (unique to this utility's base name) in the static table of synchronization
	 * locks.
	 */
	private void initAccessLock () {
		synchronized (accessLocks) {
			if (!accessLocks.containsKey(basename)) {
				accessLocks.put(basename, new Object());
			}
		}
	}
	
	/**
	 * Fetch the object that acts as the synchronization lock for this StorageUtility
	 * 
	 * @return lock object
	 */
	private Object getAccessLock () {
		synchronized (accessLocks) {
			return accessLocks.get(basename);
		}
	}
	
	/**
	 * Check that the StorageUtility has been properly initialized. Throw an exception if it is not
	 */
	public void checkInitialized () {
		checkStatusOK(true);
	}
	
	/**
	 * Check that the StorageUtility is in an initialized, consistent, non-corrupt state. Throw an exception if it is not
	 * 
	 * If the StorageUtility was not properly initialized, this call will fail.
	 * If transactions on this StorageUtility are currently in progress (such as by other threads), or a past transaction
	 *   failed and did not properly clean itself up, this call will fail. 
	 */
	public void checkNotCorrupt () {
		checkStatusOK(false);
	}
	
	/**
	 * Check the status of the StorageUtility, throwing fatal exceptions if it is in a disallowed state.
	 *   UNINITIALIZED is always a disallowed state
	 *   CLEAN is always an allowed state
	 *   DIRTY is allowed or disallowed depending on the parameter 'dirtyOK'
	 * 
	 * @param dirtyOK if true, DIRTY is an allowed status; if false, the DIRTY status will cause a fatal exception
	 */
	private void checkStatusOK (boolean dirtyOK) {
		Integer statusObj = null;
		try {
			statusObj = (Integer)getIndexStore().readRecord(TX_FLAG_REC_ID, Integer.class);
		} catch (RuntimeException re) {
			//do nothing
			System.err.println("RuntimeException while trying to read StorageUtility status flag; could be transient or could be a serious problem with RMS; " + re.getMessage());
		}
		int status = (statusObj != null ? statusObj.intValue() : STATUS_UNINITIALIZED);
		
		if (status == STATUS_DIRTY) {
			if (!dirtyOK) {
				throw new IllegalStateException("Storage utility [" + basename + "] is in a corrupted state. You must repair it before you can access it again");
			}
		} else if (status != STATUS_CLEAN) {
			throw new IllegalStateException("Storage utility [" + basename + "] was not initialized properly, is pointing at the wrong RMSes, or is otherwise seriously broken. You will likely have to delete it and start over.");			
		}
	}
	
	/**
	 * Set the status to DIRTY, indicating a transaction is in progress. Checks first to see that the status is
	 * CLEAN, else throws a fatal exception.
	 */
	private void setDirty () {
		checkNotCorrupt();
		getIndexStore().updateRecord(TX_FLAG_REC_ID, ExtUtil.serialize(new Integer(STATUS_DIRTY)));			
	}
	
	/**
	 * Set the status to CLEAN, indicating any transaction is now complete, and the StorageUtility is in a consistent state.
	 */
	private void setClean () {
		getIndexStore().updateRecord(TX_FLAG_REC_ID, ExtUtil.serialize(new Integer(STATUS_CLEAN)));
	}
	
	/**
	 * A simple wrapper around an RMS RecordStore that handles common exceptions and provides extra services like
	 * automatically opening/closing the RecordStore to free up space.
	 */
	private class RMS {
		public RecordStore rms;		//the RecordStore object being wrapper
		public String name;			//the name of this RecordStore
		
		/**
		 * Open/create an RMS and wrap it
		 * 
		 * @param name name of the RMS
		 * @param create if true, create the RMS if it does not exist
		 * @throws RecordStoreException any exception from openRecordStore() is passed on transparently
		 */
		public RMS (String name, boolean create) throws RecordStoreException {
			this.name = name;
			this.rms = RecordStore.openRecordStore(name, create);
		}
		
		/**
		 * Simple wrapper for RecordStore.addRecord(). If, on first attempt, RecordStore is full, it will
		 * close/reopen the record store to free up any available space, then try once more.
		 * 
		 * @param data record to add
		 * @return id of added record; -1 if full and no record was added
		 */
		public int addRecord (byte[] data) {
			try {
				try {
					return rms.addRecord(data, 0, data.length);
				} catch (RecordStoreFullException rsfe) {
					//do nothing
				}
				
				cycle();
				try {
					return rms.addRecord(data, 0, data.length);
				} catch (RecordStoreFullException rsfe2) {
					return -1;
				}
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error adding record to RMS; " + rse.getMessage());
			}
		}
		
		/**
		 * Simple wrapper for RecordStore.updateRecord(). If, on first attempt, RecordStore is full, it will
		 * close/reopen the record store to free up any available space, then try once more.
		 * 
		 * Error if no record for 'id' exists
		 * 
		 * @param id id of record to update
		 * @param data updated record data
		 * @return true if the record was updated; false if full
		 */
		public boolean updateRecord (int id, byte[] data) {
			try {
				try {
					rms.setRecord(id, data, 0, data.length);
					return true;
				} catch (RecordStoreFullException rsfe) {
					//do nothing
				}
				
				cycle();
				try {
					rms.setRecord(id, data, 0, data.length);
					return true;
				} catch (RecordStoreFullException rsfe2) {
					return false;
				}
			} catch (InvalidRecordIDException e) {
				throw new RuntimeException("Attempted to update a record that does not exist [" + id + "]");
			} catch (RecordStoreException e) {
				throw new RuntimeException("Error updating record in RMS; " + e.getMessage());
			}
		}
		
		/**
		 * Return the byte data for a record.
		 * 
		 * @param id record ID
		 * @return byte array of record's data; null if no record exists for that ID
		 */
		public byte[] readRecord (int id) {
			try {
				return rms.getRecord(id);
			} catch (InvalidRecordIDException iride) {
				return null;
			} catch (RecordStoreException rse) {
				throw new RuntimeException("Error reading record from RMS; " + rse.getMessage());			
			}
		}
		
		/**
		 * Return a deserialized record object
		 * 
		 * @param id record ID
		 * @param type object type of record
		 * @return record object; null if no record exists for that ID
		 */
		public Object readRecord (int id, Class type) {
			byte[] data = readRecord(id);
			try {
				return (data != null ? ExtUtil.deserialize(data, type) : null); //technically loses information for 'Nullable's
			} catch (DeserializationException de) {
				throw new RuntimeException("Error deserializing bytestream for type [" + type.getName() + "]; " + de.getMessage());
			}
		}
		
		/**
		 * Return a deserialized record object
		 * 
		 * @param id record ID
		 * @param ew ExternalizableWrapper for record type (should not use ExtWrapNull(...), as you can't distinguish the record's
		 *    data being null from null as meaning record-not-found)
		 * @return record object; null if no record exists for that ID
		 */
		public Object readRecord (int id, ExternalizableWrapper ew) {
			byte[] data = readRecord(id);
			try {
				return (data != null ? ExtUtil.deserialize(data, ew) : null);
			} catch (DeserializationException de) {
				throw new RuntimeException("Error deserializing bytestream; " + de.getMessage());
			}
		}
		
		/**
		 * Remove a record. Error if record does not exist
		 * 
		 * @param id record ID to remove
		 */
		public void removeRecord (int id) {
			try {
				rms.deleteRecord(id);
			} catch (InvalidRecordIDException e) {
				throw new RuntimeException("Attempted to remove a record that does not exist [" + id + "]");
			} catch (RecordStoreException e) {
				throw new RuntimeException("Error removing record from RMS; " + e.getMessage());
			}
		}
		
		/**
		 * Close this record store.
		 * 
		 * It will call closeRecordStore() as many times as necessary to ensure the record store is closed (this is
		 * necessary as, if the record store has been opened and never closed by other threads/StorageUtilities, our
		 * attempts to close it will have no effect; there must be one call to closeRecordStore() for each call to
		 * openRecordStore() for the record store to be truly closed).
		 */
		public void close () {
			boolean closed = false;
			
			while (!closed) {
				try {
					rms.closeRecordStore();
				} catch (RecordStoreNotOpenException e) {
					closed = true;
				} catch (RecordStoreException e) {
					throw new RuntimeException("Error closing recordstore");
				}
			}
		}
		
		/**
		 * Check that the record store is open, and reopen it if not. (It may have been closed by other threads or
		 * StorageUtilitys)
		 */
		public void ensureOpen () {
			try {
				rms.getName();
			} catch (RecordStoreNotOpenException e) {
				try {
					rms = RecordStore.openRecordStore(name, false);
				} catch (RecordStoreException e1) {
					throw new RuntimeException("error");
				}
			}
		}
		
		/**
		 * Forcibly close and re-open the record store, to trigger reclamation of any unused space.
		 */
		public void cycle () {
			try {
				close();
				rms = RecordStore.openRecordStore(name, false);
			} catch (RecordStoreException e) {
				throw new RuntimeException("error cycling recordstore");
			}
		}
	}
}

